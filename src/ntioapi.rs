use windows_sys::{
    core::GUID,
    Win32::{
        Foundation::{HANDLE, NTSTATUS, PSID, UNICODE_STRING},
        Security::SID,
        Storage::FileSystem::{
            FILE_ID_128, FILE_READ_DATA, FILE_SEGMENT_ELEMENT, FILE_WRITE_DATA,
        },
        System::{
            Ioctl::{
                FILE_ANY_ACCESS, FILE_DEVICE_MAILSLOT, FILE_DEVICE_NAMED_PIPE,
                METHOD_BUFFERED, METHOD_NEITHER,
            },
            WindowsProgramming::OBJECT_ATTRIBUTES,
        },
    },
};

use crate::{
    ctypes::{
        __int64, __uint64, c_char, c_long, c_uchar, c_ulong, c_ushort, c_void,
        wchar_t,
    },
    string::UTF16Const,
    windows_local::{shared::ntdef::LARGE_INTEGER, um::winioctl::CTL_CODE},
};

pub const FILE_SUPERSEDE: c_ulong = 0x00000000;
pub const FILE_OPEN: c_ulong = 0x00000001;
pub const FILE_CREATE: c_ulong = 0x00000002;
pub const FILE_OPEN_IF: c_ulong = 0x00000003;
pub const FILE_OVERWRITE: c_ulong = 0x00000004;
pub const FILE_OVERWRITE_IF: c_ulong = 0x00000005;
pub const FILE_MAXIMUM_DISPOSITION: c_ulong = 0x00000005;
pub const FILE_DIRECTORY_FILE: c_ulong = 0x00000001;
pub const FILE_WRITE_THROUGH: c_ulong = 0x00000002;
pub const FILE_SEQUENTIAL_ONLY: c_ulong = 0x00000004;
pub const FILE_NO_INTERMEDIATE_BUFFERING: c_ulong = 0x00000008;
pub const FILE_SYNCHRONOUS_IO_ALERT: c_ulong = 0x00000010;
pub const FILE_SYNCHRONOUS_IO_NONALERT: c_ulong = 0x00000020;
pub const FILE_NON_DIRECTORY_FILE: c_ulong = 0x00000040;
pub const FILE_CREATE_TREE_CONNECTION: c_ulong = 0x00000080;
pub const FILE_COMPLETE_IF_OPLOCKED: c_ulong = 0x00000100;
pub const FILE_NO_EA_KNOWLEDGE: c_ulong = 0x00000200;
pub const FILE_OPEN_FOR_RECOVERY: c_ulong = 0x00000400;
pub const FILE_RANDOM_ACCESS: c_ulong = 0x00000800;
pub const FILE_DELETE_ON_CLOSE: c_ulong = 0x00001000;
pub const FILE_OPEN_BY_FILE_ID: c_ulong = 0x00002000;
pub const FILE_OPEN_FOR_BACKUP_INTENT: c_ulong = 0x00004000;
pub const FILE_NO_COMPRESSION: c_ulong = 0x00008000;
pub const FILE_OPEN_REQUIRING_OPLOCK: c_ulong = 0x00010000;
pub const FILE_DISALLOW_EXCLUSIVE: c_ulong = 0x00020000;
pub const FILE_SESSION_AWARE: c_ulong = 0x00040000;
pub const FILE_RESERVE_OPFILTER: c_ulong = 0x00100000;
pub const FILE_OPEN_REPARSE_POINT: c_ulong = 0x00200000;
pub const FILE_OPEN_NO_RECALL: c_ulong = 0x00400000;
pub const FILE_OPEN_FOR_FREE_SPACE_QUERY: c_ulong = 0x00800000;
pub const FILE_COPY_STRUCTURED_STORAGE: c_ulong = 0x00000041;
pub const FILE_STRUCTURED_STORAGE: c_ulong = 0x00000441;
pub const FILE_SUPERSEDED: c_ulong = 0x00000000;
pub const FILE_OPENED: c_ulong = 0x00000001;
pub const FILE_CREATED: c_ulong = 0x00000002;
pub const FILE_OVERWRITTEN: c_ulong = 0x00000003;
pub const FILE_EXISTS: c_ulong = 0x00000004;
pub const FILE_DOES_NOT_EXIST: c_ulong = 0x00000005;
pub const FILE_WRITE_TO_END_OF_FILE: c_ulong = 0xffffffff;
pub const FILE_USE_FILE_POINTER_POSITION: c_ulong = 0xfffffffe;
pub const FILE_BYTE_ALIGNMENT: c_ulong = 0x00000000;
pub const FILE_WORD_ALIGNMENT: c_ulong = 0x00000001;
pub const FILE_LONG_ALIGNMENT: c_ulong = 0x00000003;
pub const FILE_QUAD_ALIGNMENT: c_ulong = 0x00000007;
pub const FILE_OCTA_ALIGNMENT: c_ulong = 0x0000000f;
pub const FILE_32_BYTE_ALIGNMENT: c_ulong = 0x0000001f;
pub const FILE_64_BYTE_ALIGNMENT: c_ulong = 0x0000003f;
pub const FILE_128_BYTE_ALIGNMENT: c_ulong = 0x0000007f;
pub const FILE_256_BYTE_ALIGNMENT: c_ulong = 0x000000ff;
pub const FILE_512_BYTE_ALIGNMENT: c_ulong = 0x000001ff;
pub const MAXIMUM_FILENAME_LENGTH: u32 = 256;
pub const FILE_NEED_EA: c_ulong = 0x00000080;
pub const FILE_EA_TYPE_BINARY: c_ulong = 0xfffe;
pub const FILE_EA_TYPE_ASCII: c_ulong = 0xfffd;
pub const FILE_EA_TYPE_BITMAP: c_ulong = 0xfffb;
pub const FILE_EA_TYPE_METAFILE: c_ulong = 0xfffa;
pub const FILE_EA_TYPE_ICON: c_ulong = 0xfff9;
pub const FILE_EA_TYPE_EA: c_ulong = 0xffee;
pub const FILE_EA_TYPE_MVMT: c_ulong = 0xffdf;
pub const FILE_EA_TYPE_MVST: c_ulong = 0xffde;
pub const FILE_EA_TYPE_ASN1: c_ulong = 0xffdd;
pub const FILE_EA_TYPE_FAMILY_IDS: c_ulong = 0xff01;
pub const FILE_REMOVABLE_MEDIA: c_ulong = 0x00000001;
pub const FILE_READ_ONLY_DEVICE: c_ulong = 0x00000002;
pub const FILE_FLOPPY_DISKETTE: c_ulong = 0x00000004;
pub const FILE_WRITE_ONCE_MEDIA: c_ulong = 0x00000008;
pub const FILE_REMOTE_DEVICE: c_ulong = 0x00000010;
pub const FILE_DEVICE_IS_MOUNTED: c_ulong = 0x00000020;
pub const FILE_VIRTUAL_VOLUME: c_ulong = 0x00000040;
pub const FILE_AUTOGENERATED_DEVICE_NAME: c_ulong = 0x00000080;
pub const FILE_DEVICE_SECURE_OPEN: c_ulong = 0x00000100;
pub const FILE_CHARACTERISTIC_PNP_DEVICE: c_ulong = 0x00000800;
pub const FILE_CHARACTERISTIC_TS_DEVICE: c_ulong = 0x00001000;
pub const FILE_CHARACTERISTIC_WEBDAV_DEVICE: c_ulong = 0x00002000;
pub const FILE_CHARACTERISTIC_CSV: c_ulong = 0x00010000;
pub const FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL: c_ulong = 0x00020000;
pub const FILE_PORTABLE_DEVICE: c_ulong = 0x00040000;
pub const FILE_PIPE_BYTE_STREAM_TYPE: c_ulong = 0x00000000;
pub const FILE_PIPE_MESSAGE_TYPE: c_ulong = 0x00000001;
pub const FILE_PIPE_ACCEPT_REMOTE_CLIENTS: c_ulong = 0x00000000;
pub const FILE_PIPE_REJECT_REMOTE_CLIENTS: c_ulong = 0x00000002;
pub const FILE_PIPE_TYPE_VALID_MASK: c_ulong = 0x00000003;
pub const FILE_PIPE_QUEUE_OPERATION: c_ulong = 0x00000000;
pub const FILE_PIPE_COMPLETE_OPERATION: c_ulong = 0x00000001;
pub const FILE_PIPE_BYTE_STREAM_MODE: c_ulong = 0x00000000;
pub const FILE_PIPE_MESSAGE_MODE: c_ulong = 0x00000001;
pub const FILE_PIPE_INBOUND: c_ulong = 0x00000000;
pub const FILE_PIPE_OUTBOUND: c_ulong = 0x00000001;
pub const FILE_PIPE_FULL_DUPLEX: c_ulong = 0x00000002;
pub const FILE_PIPE_DISCONNECTED_STATE: c_ulong = 0x00000001;
pub const FILE_PIPE_LISTENING_STATE: c_ulong = 0x00000002;
pub const FILE_PIPE_CONNECTED_STATE: c_ulong = 0x00000003;
pub const FILE_PIPE_CLOSING_STATE: c_ulong = 0x00000004;
pub const FILE_PIPE_CLIENT_END: c_ulong = 0x00000000;
pub const FILE_PIPE_SERVER_END: c_ulong = 0x00000001;
pub const MAILSLOT_SIZE_AUTO: u32 = 0;
UNION! {union IO_STATUS_BLOCK_u {
    Status: NTSTATUS,
    Pointer: *mut c_void,
}}
STRUCT! {struct IO_STATUS_BLOCK {
    u: IO_STATUS_BLOCK_u,
    Information: usize,
}}
pub type PIO_STATUS_BLOCK = *mut IO_STATUS_BLOCK;
FN! {stdcall PIO_APC_ROUTINE(
    ApcContext: *mut c_void,
    IoStatusBlock: PIO_STATUS_BLOCK,
    Reserved: c_ulong,
) -> ()}
STRUCT! {struct FILE_IO_COMPLETION_INFORMATION {
    KeyContext: *mut c_void,
    ApcContext: *mut c_void,
    IoStatusBlock: IO_STATUS_BLOCK,
}}
pub type PFILE_IO_COMPLETION_INFORMATION = *mut FILE_IO_COMPLETION_INFORMATION;
ENUM! {enum FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation = 2,
    FileBothDirectoryInformation = 3,
    FileBasicInformation = 4,
    FileStandardInformation = 5,
    FileInternalInformation = 6,
    FileEaInformation = 7,
    FileAccessInformation = 8,
    FileNameInformation = 9,
    FileRenameInformation = 10,
    FileLinkInformation = 11,
    FileNamesInformation = 12,
    FileDispositionInformation = 13,
    FilePositionInformation = 14,
    FileFullEaInformation = 15,
    FileModeInformation = 16,
    FileAlignmentInformation = 17,
    FileAllInformation = 18,
    FileAllocationInformation = 19,
    FileEndOfFileInformation = 20,
    FileAlternateNameInformation = 21,
    FileStreamInformation = 22,
    FilePipeInformation = 23,
    FilePipeLocalInformation = 24,
    FilePipeRemoteInformation = 25,
    FileMailslotQueryInformation = 26,
    FileMailslotSetInformation = 27,
    FileCompressionInformation = 28,
    FileObjectIdInformation = 29,
    FileCompletionInformation = 30,
    FileMoveClusterInformation = 31,
    FileQuotaInformation = 32,
    FileReparsePointInformation = 33,
    FileNetworkOpenInformation = 34,
    FileAttributeTagInformation = 35,
    FileTrackingInformation = 36,
    FileIdBothDirectoryInformation = 37,
    FileIdFullDirectoryInformation = 38,
    FileValidDataLengthInformation = 39,
    FileShortNameInformation = 40,
    FileIoCompletionNotificationInformation = 41,
    FileIoStatusBlockRangeInformation = 42,
    FileIoPriorityHintInformation = 43,
    FileSfioReserveInformation = 44,
    FileSfioVolumeInformation = 45,
    FileHardLinkInformation = 46,
    FileProcessIdsUsingFileInformation = 47,
    FileNormalizedNameInformation = 48,
    FileNetworkPhysicalNameInformation = 49,
    FileIdGlobalTxDirectoryInformation = 50,
    FileIsRemoteDeviceInformation = 51,
    FileUnusedInformation = 52,
    FileNumaNodeInformation = 53,
    FileStandardLinkInformation = 54,
    FileRemoteProtocolInformation = 55,
    FileRenameInformationBypassAccessCheck = 56,
    FileLinkInformationBypassAccessCheck = 57,
    FileVolumeNameInformation = 58,
    FileIdInformation = 59,
    FileIdExtdDirectoryInformation = 60,
    FileReplaceCompletionInformation = 61,
    FileHardLinkFullIdInformation = 62,
    FileIdExtdBothDirectoryInformation = 63,
    FileDispositionInformationEx = 64,
    FileRenameInformationEx = 65,
    FileRenameInformationExBypassAccessCheck = 66,
    FileDesiredStorageClassInformation = 67,
    FileStatInformation = 68,
    FileMemoryPartitionInformation = 69,
    FileStatLxInformation = 70,
    FileCaseSensitiveInformation = 71,
    FileLinkInformationEx = 72,
    FileLinkInformationExBypassAccessCheck = 73,
    FileStorageReserveIdInformation = 74,
    FileCaseSensitiveInformationForceAccessCheck = 75,
    FileMaximumInformation = 76,
}}
pub type PFILE_INFORMATION_CLASS = *mut FILE_INFORMATION_CLASS;
STRUCT! {struct FILE_BASIC_INFORMATION {
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    FileAttributes: c_ulong,
}}
pub type PFILE_BASIC_INFORMATION = *mut FILE_BASIC_INFORMATION;
STRUCT! {struct FILE_STANDARD_INFORMATION {
    AllocationSize: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    NumberOfLinks: c_ulong,
    DeletePending: c_uchar,
    Directory: c_uchar,
}}
pub type PFILE_STANDARD_INFORMATION = *mut FILE_STANDARD_INFORMATION;
STRUCT! {struct FILE_STANDARD_INFORMATION_EX {
    AllocationSize: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    NumberOfLinks: c_ulong,
    DeletePending: c_uchar,
    Directory: c_uchar,
    AlternateStream: c_uchar,
    MetadataAttribute: c_uchar,
}}
pub type PFILE_STANDARD_INFORMATION_EX = *mut FILE_STANDARD_INFORMATION_EX;
STRUCT! {struct FILE_INTERNAL_INFORMATION {
    IndexNumber: LARGE_INTEGER,
}}
pub type PFILE_INTERNAL_INFORMATION = *mut FILE_INTERNAL_INFORMATION;
STRUCT! {struct FILE_EA_INFORMATION {
    EaSize: c_ulong,
}}
pub type PFILE_EA_INFORMATION = *mut FILE_EA_INFORMATION;
STRUCT! {struct FILE_ACCESS_INFORMATION {
    AccessFlags: c_ulong,
}}
pub type PFILE_ACCESS_INFORMATION = *mut FILE_ACCESS_INFORMATION;
STRUCT! {struct FILE_POSITION_INFORMATION {
    CurrentByteOffset: LARGE_INTEGER,
}}
pub type PFILE_POSITION_INFORMATION = *mut FILE_POSITION_INFORMATION;
STRUCT! {struct FILE_MODE_INFORMATION {
    Mode: c_ulong,
}}
pub type PFILE_MODE_INFORMATION = *mut FILE_MODE_INFORMATION;
STRUCT! {struct FILE_ALIGNMENT_INFORMATION {
    AlignmentRequirement: c_ulong,
}}
pub type PFILE_ALIGNMENT_INFORMATION = *mut FILE_ALIGNMENT_INFORMATION;
STRUCT! {struct FILE_NAME_INFORMATION {
    FileNameLength: c_ulong,
    FileName: [wchar_t; 1],
}}
pub type PFILE_NAME_INFORMATION = *mut FILE_NAME_INFORMATION;
STRUCT! {struct FILE_ALL_INFORMATION {
    BasicInformation: FILE_BASIC_INFORMATION,
    StandardInformation: FILE_STANDARD_INFORMATION,
    InternalInformation: FILE_INTERNAL_INFORMATION,
    EaInformation: FILE_EA_INFORMATION,
    AccessInformation: FILE_ACCESS_INFORMATION,
    PositionInformation: FILE_POSITION_INFORMATION,
    ModeInformation: FILE_MODE_INFORMATION,
    AlignmentInformation: FILE_ALIGNMENT_INFORMATION,
    NameInformation: FILE_NAME_INFORMATION,
}}
pub type PFILE_ALL_INFORMATION = *mut FILE_ALL_INFORMATION;
STRUCT! {struct FILE_NETWORK_OPEN_INFORMATION {
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    FileAttributes: c_ulong,
}}
pub type PFILE_NETWORK_OPEN_INFORMATION = *mut FILE_NETWORK_OPEN_INFORMATION;
STRUCT! {struct FILE_ATTRIBUTE_TAG_INFORMATION {
    FileAttributes: c_ulong,
    ReparseTag: c_ulong,
}}
pub type PFILE_ATTRIBUTE_TAG_INFORMATION = *mut FILE_ATTRIBUTE_TAG_INFORMATION;
STRUCT! {struct FILE_ALLOCATION_INFORMATION {
    AllocationSize: LARGE_INTEGER,
}}
pub type PFILE_ALLOCATION_INFORMATION = *mut FILE_ALLOCATION_INFORMATION;
STRUCT! {struct FILE_COMPRESSION_INFORMATION {
    CompressedFileSize: LARGE_INTEGER,
    CompressionFormat: c_ushort,
    CompressionUnitShift: c_uchar,
    ChunkShift: c_uchar,
    ClusterShift: c_uchar,
    Reserved: [c_uchar; 3],
}}
pub type PFILE_COMPRESSION_INFORMATION = *mut FILE_COMPRESSION_INFORMATION;
STRUCT! {struct FILE_DISPOSITION_INFORMATION {
    DeleteFileA: c_uchar,
}}
pub type PFILE_DISPOSITION_INFORMATION = *mut FILE_DISPOSITION_INFORMATION;
STRUCT! {struct FILE_END_OF_FILE_INFORMATION {
    EndOfFile: LARGE_INTEGER,
}}
pub type PFILE_END_OF_FILE_INFORMATION = *mut FILE_END_OF_FILE_INFORMATION;
STRUCT! {struct FILE_VALID_DATA_LENGTH_INFORMATION {
    ValidDataLength: LARGE_INTEGER,
}}
pub type PFILE_VALID_DATA_LENGTH_INFORMATION =
    *mut FILE_VALID_DATA_LENGTH_INFORMATION;
STRUCT! {struct FILE_LINK_INFORMATION {
    ReplaceIfExists: c_uchar,
    RootDirectory: HANDLE,
    FileNameLength: c_ulong,
    FileName: [wchar_t; 1],
}}
pub type PFILE_LINK_INFORMATION = *mut FILE_LINK_INFORMATION;
STRUCT! {struct FILE_MOVE_CLUSTER_INFORMATION {
    ClusterCount: c_ulong,
    RootDirectory: HANDLE,
    FileNameLength: c_ulong,
    FileName: [wchar_t; 1],
}}
pub type PFILE_MOVE_CLUSTER_INFORMATION = *mut FILE_MOVE_CLUSTER_INFORMATION;
STRUCT! {struct FILE_RENAME_INFORMATION {
    ReplaceIfExists: c_uchar,
    RootDirectory: HANDLE,
    FileNameLength: c_ulong,
    FileName: [wchar_t; 1],
}}
pub type PFILE_RENAME_INFORMATION = *mut FILE_RENAME_INFORMATION;
STRUCT! {struct FILE_STREAM_INFORMATION {
    NextEntryOffset: c_ulong,
    StreamNameLength: c_ulong,
    StreamSize: LARGE_INTEGER,
    StreamAllocationSize: LARGE_INTEGER,
    StreamName: [wchar_t; 1],
}}
pub type PFILE_STREAM_INFORMATION = *mut FILE_STREAM_INFORMATION;
STRUCT! {struct FILE_TRACKING_INFORMATION {
    DestinationFile: HANDLE,
    ObjectInformationLength: c_ulong,
    ObjectInformation: [c_char; 1],
}}
pub type PFILE_TRACKING_INFORMATION = *mut FILE_TRACKING_INFORMATION;
STRUCT! {struct FILE_COMPLETION_INFORMATION {
    Port: HANDLE,
    Key: *mut c_void,
}}
pub type PFILE_COMPLETION_INFORMATION = *mut FILE_COMPLETION_INFORMATION;
STRUCT! {struct FILE_PIPE_INFORMATION {
    ReadMode: c_ulong,
    CompletionMode: c_ulong,
}}
pub type PFILE_PIPE_INFORMATION = *mut FILE_PIPE_INFORMATION;
STRUCT! {struct FILE_PIPE_LOCAL_INFORMATION {
    NamedPipeType: c_ulong,
    NamedPipeConfiguration: c_ulong,
    MaximumInstances: c_ulong,
    CurrentInstances: c_ulong,
    InboundQuota: c_ulong,
    ReadDataAvailable: c_ulong,
    OutboundQuota: c_ulong,
    WriteQuotaAvailable: c_ulong,
    NamedPipeState: c_ulong,
    NamedPipeEnd: c_ulong,
}}
pub type PFILE_PIPE_LOCAL_INFORMATION = *mut FILE_PIPE_LOCAL_INFORMATION;
STRUCT! {struct FILE_PIPE_REMOTE_INFORMATION {
    CollectDataTime: LARGE_INTEGER,
    MaximumCollectionCount: c_ulong,
}}
pub type PFILE_PIPE_REMOTE_INFORMATION = *mut FILE_PIPE_REMOTE_INFORMATION;
STRUCT! {struct FILE_MAILSLOT_QUERY_INFORMATION {
    MaximumMessageSize: c_ulong,
    MailslotQuota: c_ulong,
    NextMessageSize: c_ulong,
    MessagesAvailable: c_ulong,
    ReadTimeout: LARGE_INTEGER,
}}
pub type PFILE_MAILSLOT_QUERY_INFORMATION =
    *mut FILE_MAILSLOT_QUERY_INFORMATION;
STRUCT! {struct FILE_MAILSLOT_SET_INFORMATION {
    ReadTimeout: *mut LARGE_INTEGER,
}}
pub type PFILE_MAILSLOT_SET_INFORMATION = *mut FILE_MAILSLOT_SET_INFORMATION;
STRUCT! {struct FILE_REPARSE_POINT_INFORMATION {
    FileReference: __int64,
    Tag: c_ulong,
}}
pub type PFILE_REPARSE_POINT_INFORMATION = *mut FILE_REPARSE_POINT_INFORMATION;
STRUCT! {struct FILE_LINK_ENTRY_INFORMATION {
    NextEntryOffset: c_ulong,
    ParentFileId: __int64,
    FileNameLength: c_ulong,
    FileName: [wchar_t; 1],
}}
pub type PFILE_LINK_ENTRY_INFORMATION = *mut FILE_LINK_ENTRY_INFORMATION;
STRUCT! {struct FILE_LINKS_INFORMATION {
    BytesNeeded: c_ulong,
    EntriesReturned: c_ulong,
    Entry: FILE_LINK_ENTRY_INFORMATION,
}}
pub type PFILE_LINKS_INFORMATION = *mut FILE_LINKS_INFORMATION;
STRUCT! {struct FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
    FileNameLength: c_ulong,
    FileName: [wchar_t; 1],
}}
pub type PFILE_NETWORK_PHYSICAL_NAME_INFORMATION =
    *mut FILE_NETWORK_PHYSICAL_NAME_INFORMATION;
STRUCT! {struct FILE_STANDARD_LINK_INFORMATION {
    NumberOfAccessibleLinks: c_ulong,
    TotalNumberOfLinks: c_ulong,
    DeletePending: c_uchar,
    Directory: c_uchar,
}}
pub type PFILE_STANDARD_LINK_INFORMATION = *mut FILE_STANDARD_LINK_INFORMATION;
STRUCT! {struct FILE_SFIO_RESERVE_INFORMATION {
    RequestsPerPeriod: c_ulong,
    Period: c_ulong,
    RetryFailures: c_uchar,
    Discardable: c_uchar,
    RequestSize: c_ulong,
    NumOutstandingRequests: c_ulong,
}}
pub type PFILE_SFIO_RESERVE_INFORMATION = *mut FILE_SFIO_RESERVE_INFORMATION;
STRUCT! {struct FILE_SFIO_VOLUME_INFORMATION {
    MaximumRequestsPerPeriod: c_ulong,
    MinimumPeriod: c_ulong,
    MinimumTransferSize: c_ulong,
}}
pub type PFILE_SFIO_VOLUME_INFORMATION = *mut FILE_SFIO_VOLUME_INFORMATION;
ENUM! {enum IO_PRIORITY_HINT {
    IoPriorityVeryLow = 0,
    IoPriorityLow = 1,
    IoPriorityNormal = 2,
    IoPriorityHigh = 3,
    IoPriorityCritical = 4,
    MaxIoPriorityTypes = 5,
}}
STRUCT! {struct FILE_IO_PRIORITY_HINT_INFORMATION {
    PriorityHint: IO_PRIORITY_HINT,
}}
pub type PFILE_IO_PRIORITY_HINT_INFORMATION =
    *mut FILE_IO_PRIORITY_HINT_INFORMATION;
STRUCT! {struct FILE_IO_PRIORITY_HINT_INFORMATION_EX {
    PriorityHint: IO_PRIORITY_HINT,
    BoostOutstanding: c_uchar,
}}
pub type PFILE_IO_PRIORITY_HINT_INFORMATION_EX =
    *mut FILE_IO_PRIORITY_HINT_INFORMATION_EX;
pub const FILE_SKIP_COMPLETION_PORT_ON_SUCCESS: u32 = 0x1;
pub const FILE_SKIP_SET_EVENT_ON_HANDLE: u32 = 0x2;
pub const FILE_SKIP_SET_USER_EVENT_ON_FAST_IO: u32 = 0x4;
STRUCT! {struct FILE_IO_COMPLETION_NOTIFICATION_INFORMATION {
    Flags: c_ulong,
}}
pub type PFILE_IO_COMPLETION_NOTIFICATION_INFORMATION =
    *mut FILE_IO_COMPLETION_NOTIFICATION_INFORMATION;
STRUCT! {struct FILE_PROCESS_IDS_USING_FILE_INFORMATION {
    NumberOfProcessIdsInList: c_ulong,
    ProcessIdList: [usize; 1],
}}
pub type PFILE_PROCESS_IDS_USING_FILE_INFORMATION =
    *mut FILE_PROCESS_IDS_USING_FILE_INFORMATION;
STRUCT! {struct FILE_IS_REMOTE_DEVICE_INFORMATION {
    IsRemote: c_uchar,
}}
pub type PFILE_IS_REMOTE_DEVICE_INFORMATION =
    *mut FILE_IS_REMOTE_DEVICE_INFORMATION;
STRUCT! {struct FILE_NUMA_NODE_INFORMATION {
    NodeNumber: c_ushort,
}}
pub type PFILE_NUMA_NODE_INFORMATION = *mut FILE_NUMA_NODE_INFORMATION;
STRUCT! {struct FILE_IOSTATUSBLOCK_RANGE_INFORMATION {
    IoStatusBlockRange: *mut c_uchar,
    Length: c_ulong,
}}
pub type PFILE_IOSTATUSBLOCK_RANGE_INFORMATION =
    *mut FILE_IOSTATUSBLOCK_RANGE_INFORMATION;
STRUCT! {struct FILE_REMOTE_PROTOCOL_INFORMATION_GenericReserved {
    Reserved: [c_ulong; 8],
}}
STRUCT! {struct FILE_REMOTE_PROTOCOL_INFORMATION_ProtocolSpecific_Smb2_Server {
    Capabilities: c_ulong,
}}
STRUCT! {struct FILE_REMOTE_PROTOCOL_INFORMATION_ProtocolSpecific_Smb2_Share {
    Capabilities: c_ulong,
    CachingFlags: c_ulong,
}}
STRUCT! {struct FILE_REMOTE_PROTOCOL_INFORMATION_ProtocolSpecific_Smb2 {
    Server: FILE_REMOTE_PROTOCOL_INFORMATION_ProtocolSpecific_Smb2_Server,
    Share: FILE_REMOTE_PROTOCOL_INFORMATION_ProtocolSpecific_Smb2_Share,
}}
UNION! {union FILE_REMOTE_PROTOCOL_INFORMATION_ProtocolSpecific {
    Smb2: FILE_REMOTE_PROTOCOL_INFORMATION_ProtocolSpecific_Smb2,
    Reserved: [c_ulong; 16],
}}
STRUCT! {struct FILE_REMOTE_PROTOCOL_INFORMATION {
    StructureVersion: c_ushort,
    StructureSize: c_ushort,
    Protocol: c_ulong,
    ProtocolMajorVersion: c_ushort,
    ProtocolMinorVersion: c_ushort,
    ProtocolRevision: c_ushort,
    Reserved: c_ushort,
    Flags: c_ulong,
    GenericReserved: FILE_REMOTE_PROTOCOL_INFORMATION_GenericReserved,
    ProtocolSpecific: FILE_REMOTE_PROTOCOL_INFORMATION_ProtocolSpecific,
}}
pub type PFILE_REMOTE_PROTOCOL_INFORMATION =
    *mut FILE_REMOTE_PROTOCOL_INFORMATION;
pub const CHECKSUM_ENFORCEMENT_OFF: u32 = 0x00000001;
STRUCT! {struct FILE_INTEGRITY_STREAM_INFORMATION {
    ChecksumAlgorithm: c_ushort,
    ChecksumChunkShift: c_uchar,
    ClusterShift: c_uchar,
    Flags: c_ulong,
}}
pub type PFILE_INTEGRITY_STREAM_INFORMATION =
    *mut FILE_INTEGRITY_STREAM_INFORMATION;
STRUCT! {struct FILE_VOLUME_NAME_INFORMATION {
    DeviceNameLength: c_ulong,
    DeviceName: [wchar_t; 1],
}}
pub type PFILE_VOLUME_NAME_INFORMATION = *mut FILE_VOLUME_NAME_INFORMATION;
STRUCT! {struct FILE_ID_INFORMATION {
    VolumeSerialNumber: __uint64,
    FileId: FILE_ID_128,
}}
pub type PFILE_ID_INFORMATION = *mut FILE_ID_INFORMATION;
STRUCT! {struct FILE_ID_EXTD_DIR_INFORMATION {
    NextEntryOffset: c_ulong,
    FileIndex: c_ulong,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: c_ulong,
    FileNameLength: c_ulong,
    EaSize: c_ulong,
    ReparsePointTag: c_ulong,
    FileId: FILE_ID_128,
    FileName: [wchar_t; 1],
}}
pub type PFILE_ID_EXTD_DIR_INFORMATION = *mut FILE_ID_EXTD_DIR_INFORMATION;
STRUCT! {struct FILE_LINK_ENTRY_FULL_ID_INFORMATION {
    NextEntryOffset: c_ulong,
    ParentFileId: FILE_ID_128,
    FileNameLength: c_ulong,
    FileName: [wchar_t; 1],
}}
pub type PFILE_LINK_ENTRY_FULL_ID_INFORMATION =
    *mut FILE_LINK_ENTRY_FULL_ID_INFORMATION;
STRUCT! {struct FILE_ID_EXTD_BOTH_DIR_INFORMATION {
    NextEntryOffset: c_ulong,
    FileIndex: c_ulong,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: c_ulong,
    FileNameLength: c_ulong,
    EaSize: c_ulong,
    ReparsePointTag: c_ulong,
    FileId: FILE_ID_128,
    ShortNameLength: c_char,
    ShortName: [wchar_t; 12],
    FileName: [wchar_t; 1],
}}
pub type PFILE_ID_EXTD_BOTH_DIR_INFORMATION =
    *mut FILE_ID_EXTD_BOTH_DIR_INFORMATION;
STRUCT! {struct FILE_STAT_INFORMATION {
    FileId: LARGE_INTEGER,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    FileAttributes: c_ulong,
    ReparseTag: c_ulong,
    NumberOfLinks: c_ulong,
    EffectiveAccess: c_ulong,
}}
pub type PFILE_STAT_INFORMATION = *mut FILE_STAT_INFORMATION;
STRUCT! {struct FILE_MEMORY_PARTITION_INFORMATION_Flags_s {
    NoCrossPartitionAccess: c_uchar,
    Spare: [c_uchar; 3],
}}
UNION! {union FILE_MEMORY_PARTITION_INFORMATION_Flags {
    s: FILE_MEMORY_PARTITION_INFORMATION_Flags_s,
    AllFlags: c_ulong,
}}
STRUCT! {struct FILE_MEMORY_PARTITION_INFORMATION {
    OwnerPartitionHandle: HANDLE,
    Flags: FILE_MEMORY_PARTITION_INFORMATION_Flags,
}}
pub type PFILE_MEMORY_PARTITION_INFORMATION =
    *mut FILE_MEMORY_PARTITION_INFORMATION;
STRUCT! {struct FILE_STAT_LX_INFORMATION {
    FileId: LARGE_INTEGER,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    FileAttributes: c_ulong,
    ReparseTag: c_ulong,
    NumberOfLinks: c_ulong,
    EffectiveAccess: c_ulong,
    LxFlags: c_ulong,
    LxUid: c_ulong,
    LxGid: c_ulong,
    LxMode: c_ulong,
    LxDeviceIdMajor: c_ulong,
    LxDeviceIdMinor: c_ulong,
}}
pub type PFILE_STAT_LX_INFORMATION = *mut FILE_STAT_LX_INFORMATION;
STRUCT! {struct FILE_CASE_SENSITIVE_INFORMATION {
    Flags: c_ulong,
}}
pub type PFILE_CASE_SENSITIVE_INFORMATION =
    *mut FILE_CASE_SENSITIVE_INFORMATION;
STRUCT! {struct FILE_DIRECTORY_INFORMATION {
    NextEntryOffset: c_ulong,
    FileIndex: c_ulong,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: c_ulong,
    FileNameLength: c_ulong,
    FileName: [wchar_t; 1],
}}
pub type PFILE_DIRECTORY_INFORMATION = *mut FILE_DIRECTORY_INFORMATION;
STRUCT! {struct FILE_FULL_DIR_INFORMATION {
    NextEntryOffset: c_ulong,
    FileIndex: c_ulong,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: c_ulong,
    FileNameLength: c_ulong,
    EaSize: c_ulong,
    FileName: [wchar_t; 1],
}}
pub type PFILE_FULL_DIR_INFORMATION = *mut FILE_FULL_DIR_INFORMATION;
STRUCT! {struct FILE_ID_FULL_DIR_INFORMATION {
    NextEntryOffset: c_ulong,
    FileIndex: c_ulong,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: c_ulong,
    FileNameLength: c_ulong,
    EaSize: c_ulong,
    FileId: LARGE_INTEGER,
    FileName: [wchar_t; 1],
}}
pub type PFILE_ID_FULL_DIR_INFORMATION = *mut FILE_ID_FULL_DIR_INFORMATION;
STRUCT! {struct FILE_BOTH_DIR_INFORMATION {
    NextEntryOffset: c_ulong,
    FileIndex: c_ulong,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: c_ulong,
    FileNameLength: c_ulong,
    EaSize: c_ulong,
    ShortNameLength: c_char,
    ShortName: [wchar_t; 12],
    FileName: [wchar_t; 1],
}}
pub type PFILE_BOTH_DIR_INFORMATION = *mut FILE_BOTH_DIR_INFORMATION;
STRUCT! {struct FILE_ID_BOTH_DIR_INFORMATION {
    NextEntryOffset: c_ulong,
    FileIndex: c_ulong,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: c_ulong,
    FileNameLength: c_ulong,
    EaSize: c_ulong,
    ShortNameLength: c_char,
    ShortName: [wchar_t; 12],
    FileId: LARGE_INTEGER,
    FileName: [wchar_t; 1],
}}
pub type PFILE_ID_BOTH_DIR_INFORMATION = *mut FILE_ID_BOTH_DIR_INFORMATION;
STRUCT! {struct FILE_NAMES_INFORMATION {
    NextEntryOffset: c_ulong,
    FileIndex: c_ulong,
    FileNameLength: c_ulong,
    FileName: [wchar_t; 1],
}}
pub type PFILE_NAMES_INFORMATION = *mut FILE_NAMES_INFORMATION;
STRUCT! {struct FILE_ID_GLOBAL_TX_DIR_INFORMATION {
    NextEntryOffset: c_ulong,
    FileIndex: c_ulong,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: c_ulong,
    FileNameLength: c_ulong,
    FileId: LARGE_INTEGER,
    LockingTransactionId: GUID,
    TxInfoFlags: c_ulong,
    FileName: [wchar_t; 1],
}}
pub type PFILE_ID_GLOBAL_TX_DIR_INFORMATION =
    *mut FILE_ID_GLOBAL_TX_DIR_INFORMATION;
pub const FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_WRITELOCKED: u32 = 0x00000001;
pub const FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_TO_TX: u32 = 0x00000002;
pub const FILE_ID_GLOBAL_TX_DIR_INFO_FLAG_VISIBLE_OUTSIDE_TX: u32 = 0x00000004;
STRUCT! {struct FILE_OBJECTID_INFORMATION_u_s {
    BirthVolumeId: [c_uchar; 16],
    BirthObjectId: [c_uchar; 16],
    DomainId: [c_uchar; 16],
}}
UNION! {union FILE_OBJECTID_INFORMATION_u {
    s: FILE_OBJECTID_INFORMATION_u_s,
    ExtendedInfo: [c_uchar; 48],
}}
STRUCT! {struct FILE_OBJECTID_INFORMATION {
    FileReference: __int64,
    ObjectId: [c_uchar; 16],
    u: FILE_OBJECTID_INFORMATION_u,
}}
pub type PFILE_OBJECTID_INFORMATION = *mut FILE_OBJECTID_INFORMATION;
STRUCT! {struct FILE_FULL_EA_INFORMATION {
    NextEntryOffset: c_ulong,
    Flags: c_uchar,
    EaNameLength: c_uchar,
    EaValueLength: c_ushort,
    EaName: [c_char; 1],
}}
pub type PFILE_FULL_EA_INFORMATION = *mut FILE_FULL_EA_INFORMATION;
STRUCT! {struct FILE_GET_EA_INFORMATION {
    NextEntryOffset: c_ulong,
    EaNameLength: c_uchar,
    EaName: [c_char; 1],
}}
pub type PFILE_GET_EA_INFORMATION = *mut FILE_GET_EA_INFORMATION;
STRUCT! {struct FILE_GET_QUOTA_INFORMATION {
    NextEntryOffset: c_ulong,
    SidLength: c_ulong,
    Sid: SID,
}}
pub type PFILE_GET_QUOTA_INFORMATION = *mut FILE_GET_QUOTA_INFORMATION;
STRUCT! {struct FILE_QUOTA_INFORMATION {
    NextEntryOffset: c_ulong,
    SidLength: c_ulong,
    ChangeTime: LARGE_INTEGER,
    QuotaUsed: LARGE_INTEGER,
    QuotaThreshold: LARGE_INTEGER,
    QuotaLimit: LARGE_INTEGER,
    Sid: SID,
}}
pub type PFILE_QUOTA_INFORMATION = *mut FILE_QUOTA_INFORMATION;
ENUM! {enum FS_INFORMATION_CLASS {
    FileFsVolumeInformation = 1,
    FileFsLabelInformation = 2,
    FileFsSizeInformation = 3,
    FileFsDeviceInformation = 4,
    FileFsAttributeInformation = 5,
    FileFsControlInformation = 6,
    FileFsFullSizeInformation = 7,
    FileFsObjectIdInformation = 8,
    FileFsDriverPathInformation = 9,
    FileFsVolumeFlagsInformation = 10,
    FileFsSectorSizeInformation = 11,
    FileFsDataCopyInformation = 12,
    FileFsMetadataSizeInformation = 13,
    FileFsFullSizeInformationEx = 14,
    FileFsMaximumInformation = 15,
}}
pub type PFS_INFORMATION_CLASS = *mut FS_INFORMATION_CLASS;
STRUCT! {struct FILE_FS_LABEL_INFORMATION {
    VolumeLabelLength: c_ulong,
    VolumeLabel: [wchar_t; 1],
}}
pub type PFILE_FS_LABEL_INFORMATION = *mut FILE_FS_LABEL_INFORMATION;
STRUCT! {struct FILE_FS_VOLUME_INFORMATION {
    VolumeCreationTime: LARGE_INTEGER,
    VolumeSerialNumber: c_ulong,
    VolumeLabelLength: c_ulong,
    SupportsObjects: c_uchar,
    VolumeLabel: [wchar_t; 1],
}}
pub type PFILE_FS_VOLUME_INFORMATION = *mut FILE_FS_VOLUME_INFORMATION;
STRUCT! {struct FILE_FS_SIZE_INFORMATION {
    TotalAllocationUnits: LARGE_INTEGER,
    AvailableAllocationUnits: LARGE_INTEGER,
    SectorsPerAllocationUnit: c_ulong,
    BytesPerSector: c_ulong,
}}
pub type PFILE_FS_SIZE_INFORMATION = *mut FILE_FS_SIZE_INFORMATION;
STRUCT! {struct FILE_FS_CONTROL_INFORMATION {
    FreeSpaceStartFiltering: LARGE_INTEGER,
    FreeSpaceThreshold: LARGE_INTEGER,
    FreeSpaceStopFiltering: LARGE_INTEGER,
    DefaultQuotaThreshold: LARGE_INTEGER,
    DefaultQuotaLimit: LARGE_INTEGER,
    FileSystemControlFlags: c_ulong,
}}
pub type PFILE_FS_CONTROL_INFORMATION = *mut FILE_FS_CONTROL_INFORMATION;
STRUCT! {struct FILE_FS_FULL_SIZE_INFORMATION {
    TotalAllocationUnits: LARGE_INTEGER,
    CallerAvailableAllocationUnits: LARGE_INTEGER,
    ActualAvailableAllocationUnits: LARGE_INTEGER,
    SectorsPerAllocationUnit: c_ulong,
    BytesPerSector: c_ulong,
}}
pub type PFILE_FS_FULL_SIZE_INFORMATION = *mut FILE_FS_FULL_SIZE_INFORMATION;
STRUCT! {struct FILE_FS_OBJECTID_INFORMATION {
    ObjectId: [c_uchar; 16],
    ExtendedInfo: [c_uchar; 48],
}}
pub type PFILE_FS_OBJECTID_INFORMATION = *mut FILE_FS_OBJECTID_INFORMATION;
STRUCT! {struct FILE_FS_DEVICE_INFORMATION {
    DeviceType: c_ulong,
    Characteristics: c_ulong,
}}
pub type PFILE_FS_DEVICE_INFORMATION = *mut FILE_FS_DEVICE_INFORMATION;
STRUCT! {struct FILE_FS_ATTRIBUTE_INFORMATION {
    FileSystemAttributes: c_ulong,
    MaximumComponentNameLength: c_long,
    FileSystemNameLength: c_ulong,
    FileSystemName: [wchar_t; 1],
}}
pub type PFILE_FS_ATTRIBUTE_INFORMATION = *mut FILE_FS_ATTRIBUTE_INFORMATION;
STRUCT! {struct FILE_FS_DRIVER_PATH_INFORMATION {
    DriverInPath: c_uchar,
    DriverNameLength: c_ulong,
    DriverName: [wchar_t; 1],
}}
pub type PFILE_FS_DRIVER_PATH_INFORMATION =
    *mut FILE_FS_DRIVER_PATH_INFORMATION;
STRUCT! {struct FILE_FS_VOLUME_FLAGS_INFORMATION {
    Flags: c_ulong,
}}
pub type PFILE_FS_VOLUME_FLAGS_INFORMATION =
    *mut FILE_FS_VOLUME_FLAGS_INFORMATION;
pub const SSINFO_FLAGS_ALIGNED_DEVICE: u32 = 0x00000001;
pub const SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE: u32 = 0x00000002;
pub const SSINFO_OFFSET_UNKNOWN: u32 = 0xffffffff;
STRUCT! {struct FILE_FS_SECTOR_SIZE_INFORMATION {
    LogicalBytesPerSector: c_ulong,
    PhysicalBytesPerSectorForAtomicity: c_ulong,
    PhysicalBytesPerSectorForPerformance: c_ulong,
    FileSystemEffectivePhysicalBytesPerSectorForAtomicity: c_ulong,
    Flags: c_ulong,
    ByteOffsetForSectorAlignment: c_ulong,
    ByteOffsetForPartitionAlignment: c_ulong,
}}
pub type PFILE_FS_SECTOR_SIZE_INFORMATION =
    *mut FILE_FS_SECTOR_SIZE_INFORMATION;
STRUCT! {struct FILE_FS_DATA_COPY_INFORMATION {
    NumberOfCopies: c_ulong,
}}
pub type PFILE_FS_DATA_COPY_INFORMATION = *mut FILE_FS_DATA_COPY_INFORMATION;
STRUCT! {struct FILE_FS_METADATA_SIZE_INFORMATION {
    TotalMetadataAllocationUnits: LARGE_INTEGER,
    SectorsPerAllocationUnit: c_ulong,
    BytesPerSector: c_ulong,
}}
pub type PFILE_FS_METADATA_SIZE_INFORMATION =
    *mut FILE_FS_METADATA_SIZE_INFORMATION;
STRUCT! {struct FILE_FS_FULL_SIZE_INFORMATION_EX {
    ActualTotalAllocationUnits: __uint64,
    ActualAvailableAllocationUnits: __uint64,
    ActualPoolUnavailableAllocationUnits: __uint64,
    CallerTotalAllocationUnits: __uint64,
    CallerAvailableAllocationUnits: __uint64,
    CallerPoolUnavailableAllocationUnits: __uint64,
    UsedAllocationUnits: __uint64,
    TotalReservedAllocationUnits: __uint64,
    VolumeStorageReserveAllocationUnits: __uint64,
    AvailableCommittedAllocationUnits: __uint64,
    PoolAvailableAllocationUnits: __uint64,
    SectorsPerAllocationUnit: c_ulong,
    BytesPerSector: c_ulong,
}}
pub type PFILE_FS_FULL_SIZE_INFORMATION_EX =
    *mut FILE_FS_FULL_SIZE_INFORMATION_EX;
EXTERN! {extern "system" {
    fn NtCreateFile(
        FileHandle: *mut HANDLE,
        DesiredAccess: c_ulong,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: *mut LARGE_INTEGER,
        FileAttributes: c_ulong,
        ShareAccess: c_ulong,
        CreateDisposition: c_ulong,
        CreateOptions: c_ulong,
        EaBuffer: *mut c_void,
        EaLength: c_ulong,
    ) -> NTSTATUS;
    fn NtCreateNamedPipeFile(
        FileHandle: *mut HANDLE,
        DesiredAccess: c_ulong,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        ShareAccess: c_ulong,
        CreateDisposition: c_ulong,
        CreateOptions: c_ulong,
        NamedPipeType: c_ulong,
        ReadMode: c_ulong,
        CompletionMode: c_ulong,
        MaximumInstances: c_ulong,
        InboundQuota: c_ulong,
        OutboundQuota: c_ulong,
        DefaultTimeout: *mut LARGE_INTEGER,
    ) -> NTSTATUS;
    fn NtCreateMailslotFile(
        FileHandle: *mut HANDLE,
        DesiredAccess: c_ulong,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        CreateOptions: c_ulong,
        MailslotQuota: c_ulong,
        MaximumMessageSize: c_ulong,
        ReadTimeout: *mut LARGE_INTEGER,
    ) -> NTSTATUS;
    fn NtOpenFile(
        FileHandle: *mut HANDLE,
        DesiredAccess: c_ulong,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        ShareAccess: c_ulong,
        OpenOptions: c_ulong,
    ) -> NTSTATUS;
    fn NtDeleteFile(
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
    fn NtFlushBuffersFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> NTSTATUS;
    fn NtFlushBuffersFileEx(
        FileHandle: HANDLE,
        Flags: c_ulong,
        Parameters: *mut c_void,
        ParametersSize: c_ulong,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> NTSTATUS;
    fn NtQueryInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: *mut c_void,
        Length: c_ulong,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
    fn NtQueryInformationByName(
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: *mut c_void,
        Length: c_ulong,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
    fn NtSetInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: *mut c_void,
        Length: c_ulong,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
    fn NtQueryDirectoryFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: *mut c_void,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: *mut c_void,
        Length: c_ulong,
        FileInformationClass: FILE_INFORMATION_CLASS,
        ReturnSingleEntry: c_uchar,
        FileName: *mut UNICODE_STRING,
        RestartScan: c_uchar,
    ) -> NTSTATUS;
    fn NtQueryEaFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: *mut c_void,
        Length: c_ulong,
        ReturnSingleEntry: c_uchar,
        EaList: *mut c_void,
        EaListLength: c_ulong,
        EaIndex: *mut c_ulong,
        RestartScan: c_uchar,
    ) -> NTSTATUS;
    fn NtSetEaFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: *mut c_void,
        Length: c_ulong,
    ) -> NTSTATUS;
    fn NtQueryQuotaInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: *mut c_void,
        Length: c_ulong,
        ReturnSingleEntry: c_uchar,
        SidList: *mut c_void,
        SidListLength: c_ulong,
        StartSid: PSID,
        RestartScan: c_uchar,
    ) -> NTSTATUS;
    fn NtSetQuotaInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: *mut c_void,
        Length: c_ulong,
    ) -> NTSTATUS;
    fn NtQueryVolumeInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FsInformation: *mut c_void,
        Length: c_ulong,
        FsInformationClass: FS_INFORMATION_CLASS,
    ) -> NTSTATUS;
    fn NtSetVolumeInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FsInformation: *mut c_void,
        Length: c_ulong,
        FsInformationClass: FS_INFORMATION_CLASS,
    ) -> NTSTATUS;
    fn NtCancelIoFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> NTSTATUS;
    fn NtCancelIoFileEx(
        FileHandle: HANDLE,
        IoRequestToCancel: PIO_STATUS_BLOCK,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> NTSTATUS;
    fn NtCancelSynchronousIoFile(
        ThreadHandle: HANDLE,
        IoRequestToCancel: PIO_STATUS_BLOCK,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> NTSTATUS;
    fn NtDeviceIoControlFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: *mut c_void,
        IoStatusBlock: PIO_STATUS_BLOCK,
        IoControlCode: c_ulong,
        InputBuffer: *mut c_void,
        InputBufferLength: c_ulong,
        OutputBuffer: *mut c_void,
        OutputBufferLength: c_ulong,
    ) -> NTSTATUS;
    fn NtFsControlFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: *mut c_void,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FsControlCode: c_ulong,
        InputBuffer: *mut c_void,
        InputBufferLength: c_ulong,
        OutputBuffer: *mut c_void,
        OutputBufferLength: c_ulong,
    ) -> NTSTATUS;
    fn NtReadFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: *mut c_void,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: *mut c_void,
        Length: c_ulong,
        ByteOffset: *mut LARGE_INTEGER,
        Key: *mut c_ulong,
    ) -> NTSTATUS;
    fn NtWriteFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: *mut c_void,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: *mut c_void,
        Length: c_ulong,
        ByteOffset: *mut LARGE_INTEGER,
        Key: *mut c_ulong,
    ) -> NTSTATUS;
    fn NtReadFileScatter(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: *mut c_void,
        IoStatusBlock: PIO_STATUS_BLOCK,
        SegmentArray: *mut FILE_SEGMENT_ELEMENT,
        Length: c_ulong,
        ByteOffset: *mut LARGE_INTEGER,
        Key: *mut c_ulong,
    ) -> NTSTATUS;
    fn NtWriteFileGather(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: *mut c_void,
        IoStatusBlock: PIO_STATUS_BLOCK,
        SegmentArray: *mut FILE_SEGMENT_ELEMENT,
        Length: c_ulong,
        ByteOffset: *mut LARGE_INTEGER,
        Key: *mut c_ulong,
    ) -> NTSTATUS;
    fn NtLockFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: *mut c_void,
        IoStatusBlock: PIO_STATUS_BLOCK,
        ByteOffset: *mut LARGE_INTEGER,
        Length: *mut LARGE_INTEGER,
        Key: c_ulong,
        FailImmediately: c_uchar,
        ExclusiveLock: c_uchar,
    ) -> NTSTATUS;
    fn NtUnlockFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        ByteOffset: *mut LARGE_INTEGER,
        Length: *mut LARGE_INTEGER,
        Key: c_ulong,
    ) -> NTSTATUS;
    fn NtQueryAttributesFile(
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
        FileInformation: PFILE_BASIC_INFORMATION,
    ) -> NTSTATUS;
    fn NtQueryFullAttributesFile(
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
        FileInformation: PFILE_NETWORK_OPEN_INFORMATION,
    ) -> NTSTATUS;
    fn NtNotifyChangeDirectoryFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: *mut c_void,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: *mut c_void,
        Length: c_ulong,
        CompletionFilter: c_ulong,
        WatchTree: c_uchar,
    ) -> NTSTATUS;
    fn NtLoadDriver(
        DriverServiceName: *mut UNICODE_STRING,
    ) -> NTSTATUS;
    fn NtUnloadDriver(
        DriverServiceName: *mut UNICODE_STRING,
    ) -> NTSTATUS;
}}
pub const IO_COMPLETION_QUERY_STATE: u32 = 0x0001;
ENUM! {enum IO_COMPLETION_INFORMATION_CLASS {
    IoCompletionBasicInformation = 0,
}}
STRUCT! {struct IO_COMPLETION_BASIC_INFORMATION {
    Depth: c_long,
}}
pub type PIO_COMPLETION_BASIC_INFORMATION =
    *mut IO_COMPLETION_BASIC_INFORMATION;
EXTERN! {extern "system" {
    fn NtCreateIoCompletion(
        IoCompletionHandle: *mut HANDLE,
        DesiredAccess: c_ulong,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
        Count: c_ulong,
    ) -> NTSTATUS;
    fn NtOpenIoCompletion(
        IoCompletionHandle: *mut HANDLE,
        DesiredAccess: c_ulong,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
    fn NtQueryIoCompletion(
        IoCompletionHandle: HANDLE,
        IoCompletionInformationClass: IO_COMPLETION_INFORMATION_CLASS,
        IoCompletionInformation: *mut c_void,
        IoCompletionInformationLength: c_ulong,
        ReturnLength: *mut c_ulong,
    ) -> NTSTATUS;
    fn NtSetIoCompletion(
        IoCompletionHandle: HANDLE,
        KeyContext: *mut c_void,
        ApcContext: *mut c_void,
        IoStatus: NTSTATUS,
        IoStatusInformation: usize,
    ) -> NTSTATUS;
    fn NtSetIoCompletionEx(
        IoCompletionHandle: HANDLE,
        IoCompletionPacketHandle: HANDLE,
        KeyContext: *mut c_void,
        ApcContext: *mut c_void,
        IoStatus: NTSTATUS,
        IoStatusInformation: usize,
    ) -> NTSTATUS;
    fn NtRemoveIoCompletion(
        IoCompletionHandle: HANDLE,
        KeyContext: *mut *mut c_void,
        ApcContext: *mut *mut c_void,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Timeout: *mut LARGE_INTEGER,
    ) -> NTSTATUS;
    fn NtRemoveIoCompletionEx(
        IoCompletionHandle: HANDLE,
        IoCompletionInformation: PFILE_IO_COMPLETION_INFORMATION,
        Count: c_ulong,
        NumEntriesRemoved: *mut c_ulong,
        Timeout: *mut LARGE_INTEGER,
        Alertable: c_uchar,
    ) -> NTSTATUS;
    fn NtCreateWaitCompletionPacket(
        WaitCompletionPacketHandle: *mut HANDLE,
        DesiredAccess: c_ulong,
        ObjectAttributes: *mut OBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
    fn NtAssociateWaitCompletionPacket(
        WaitCompletionPacketHandle: HANDLE,
        IoCompletionHandle: HANDLE,
        TargetObjectHandle: HANDLE,
        KeyContext: *mut c_void,
        ApcContext: *mut c_void,
        IoStatus: NTSTATUS,
        IoStatusInformation: usize,
        AlreadySignaled: *mut c_uchar,
    ) -> NTSTATUS;
    fn NtCancelWaitCompletionPacket(
        WaitCompletionPacketHandle: HANDLE,
        RemoveSignaledPacket: c_uchar,
    ) -> NTSTATUS;
}}
ENUM! {enum IO_SESSION_EVENT {
    IoSessionEventIgnore = 0,
    IoSessionEventCreated = 1,
    IoSessionEventTerminated = 2,
    IoSessionEventConnected = 3,
    IoSessionEventDisconnected = 4,
    IoSessionEventLogon = 5,
    IoSessionEventLogoff = 6,
    IoSessionEventMax = 7,
}}
ENUM! {enum IO_SESSION_STATE {
    IoSessionStateCreated = 0,
    IoSessionStateInitialized = 1,
    IoSessionStateConnected = 2,
    IoSessionStateDisconnected = 3,
    IoSessionStateDisconnectedLoggedOn = 4,
    IoSessionStateLoggedOn = 5,
    IoSessionStateLoggedOff = 6,
    IoSessionStateTerminated = 7,
    IoSessionStateMax = 8,
}}
EXTERN! {extern "system" {
    fn NtNotifyChangeSession(
        SessionHandle: HANDLE,
        ChangeSequenceNumber: c_ulong,
        ChangeTimeStamp: *mut LARGE_INTEGER,
        Event: IO_SESSION_EVENT,
        NewState: IO_SESSION_STATE,
        PreviousState: IO_SESSION_STATE,
        Payload: *mut c_void,
        PayloadSize: c_ulong,
    ) -> NTSTATUS;
}}
ENUM! {enum INTERFACE_TYPE {
    InterfaceTypeUndefined = -1i32 as u32,
    Internal = 0,
    Isa = 1,
    Eisa = 2,
    MicroChannel = 3,
    TurboChannel = 4,
    PCIBus = 5,
    VMEBus = 6,
    NuBus = 7,
    PCMCIABus = 8,
    CBus = 9,
    MPIBus = 10,
    MPSABus = 11,
    ProcessorInternal = 12,
    InternalPowerBus = 13,
    PNPISABus = 14,
    PNPBus = 15,
    Vmcs = 16,
    MaximumInterfaceType = 17,
}}
pub type PINTERFACE_TYPE = *mut INTERFACE_TYPE;
ENUM! {enum DMA_WIDTH {
    Width8Bits = 0,
    Width16Bits = 1,
    Width32Bits = 2,
    MaximumDmaWidth = 3,
}}
pub type PDMA_WIDTH = *mut DMA_WIDTH;
ENUM! {enum DMA_SPEED {
    Compatible = 0,
    TypeA = 1,
    TypeB = 2,
    TypeC = 3,
    TypeF = 4,
    MaximumDmaSpeed = 5,
}}
pub type PDMA_SPEED = *mut DMA_SPEED;
ENUM! {enum BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1i32 as u32,
    Cmos = 0,
    EisaConfiguration = 1,
    Pos = 2,
    CbusConfiguration = 3,
    PCIConfiguration = 4,
    VMEConfiguration = 5,
    NuBusConfiguration = 6,
    PCMCIAConfiguration = 7,
    MPIConfiguration = 8,
    MPSAConfiguration = 9,
    PNPISAConfiguration = 10,
    SgiInternalConfiguration = 11,
    MaximumBusDataType = 12,
}}
pub type PBUS_DATA_TYPE = *mut BUS_DATA_TYPE;
pub const SYMLINK_FLAG_RELATIVE: u32 = 1;
STRUCT! {struct REPARSE_DATA_BUFFER_u_SymbolicLinkReparseBuffer {
    SubstituteNameOffset: c_ushort,
    SubstituteNameLength: c_ushort,
    PrintNameOffset: c_ushort,
    PrintNameLength: c_ushort,
    Flags: c_ulong,
    PathBuffer: [wchar_t; 1],
}}
STRUCT! {struct REPARSE_DATA_BUFFER_u_MountPointReparseBuffer {
    SubstituteNameOffset: c_ushort,
    SubstituteNameLength: c_ushort,
    PrintNameOffset: c_ushort,
    PrintNameLength: c_ushort,
    PathBuffer: [wchar_t; 1],
}}
STRUCT! {struct REPARSE_DATA_BUFFER_u_GenericReparseBuffer {
    DataBuffer: [c_uchar; 1],
}}
UNION! {union REPARSE_DATA_BUFFER_u {
    SymbolicLinkReparseBuffer: REPARSE_DATA_BUFFER_u_SymbolicLinkReparseBuffer,
    MountPointReparseBuffer: REPARSE_DATA_BUFFER_u_MountPointReparseBuffer,
    GenericReparseBuffer: REPARSE_DATA_BUFFER_u_GenericReparseBuffer,
}}
STRUCT! {struct REPARSE_DATA_BUFFER {
    ReparseTag: c_ulong,
    ReparseDataLength: c_ushort,
    Reserved: c_ushort,
    u: REPARSE_DATA_BUFFER_u,
}}
pub type PREPARSE_DATA_BUFFER = *mut REPARSE_DATA_BUFFER;
/// "\Device\NamedPipe\"
pub const DEVICE_NAMED_PIPE: UTF16Const = UTF16Const(&[
    0x005C, 0x0044, 0x0065, 0x0076, 0x0069, 0x0063, 0x0065, 0x005C, 0x004E,
    0x0061, 0x006D, 0x0065, 0x0064, 0x0050, 0x0069, 0x0070, 0x0065, 0x005C,
    0u16,
]);
pub const FSCTL_PIPE_ASSIGN_EVENT: u32 =
    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS);
pub const FSTL_PIPE_DISCONNECT: u32 =
    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS);
pub const FSTL_PIPE_LISTEN: u32 =
    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS);
pub const FSTL_PIPE_PEEK: u32 =
    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 3, METHOD_BUFFERED, FILE_READ_DATA);
pub const FSTL_PIPE_QUERY_EVENT: u32 =
    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS);
pub const FSTL_PIPE_TRANSCEIVE: u32 = CTL_CODE(
    FILE_DEVICE_NAMED_PIPE,
    5,
    METHOD_NEITHER,
    FILE_READ_DATA | FILE_WRITE_DATA,
);
pub const FSTL_PIPE_WAIT: u32 =
    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS);
pub const FSTL_PIPE_IMPERSONATE: u32 =
    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS);
pub const FSTL_PIPE_SET_CLIENT_PROCESS: u32 =
    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 8, METHOD_BUFFERED, FILE_ANY_ACCESS);
pub const FSTL_PIPE_QUERY_CLIENT_PROCESS: u32 =
    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 9, METHOD_BUFFERED, FILE_ANY_ACCESS);
pub const FSTL_PIPE_GET_PIPE_ATTRIBUTE: u32 =
    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 10, METHOD_BUFFERED, FILE_ANY_ACCESS);
pub const FSTL_PIPE_SET_PIPE_ATTRIBUTE: u32 =
    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 11, METHOD_BUFFERED, FILE_ANY_ACCESS);
pub const FSTL_PIPE_GET_CONNECTION_ATTRIBUTE: u32 =
    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS);
pub const FSTL_PIPE_SET_CONNECTION_ATTRIBUTE: u32 =
    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS);
pub const FSTL_PIPE_GET_HANDLE_ATTRIBUTE: u32 =
    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 14, METHOD_BUFFERED, FILE_ANY_ACCESS);
pub const FSTL_PIPE_SET_HANDLE_ATTRIBUTE: u32 =
    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 15, METHOD_BUFFERED, FILE_ANY_ACCESS);
pub const FSTL_PIPE_FLUSH: u32 =
    CTL_CODE(FILE_DEVICE_NAMED_PIPE, 16, METHOD_BUFFERED, FILE_WRITE_DATA);
pub const FSTL_PIPE_INTERNAL_READ: u32 = CTL_CODE(
    FILE_DEVICE_NAMED_PIPE,
    2045,
    METHOD_BUFFERED,
    FILE_READ_DATA,
);
pub const FSTL_PIPE_INTERNAL_WRITE: u32 = CTL_CODE(
    FILE_DEVICE_NAMED_PIPE,
    2046,
    METHOD_BUFFERED,
    FILE_WRITE_DATA,
);
pub const FSTL_PIPE_INTERNAL_TRANSCEIVE: u32 = CTL_CODE(
    FILE_DEVICE_NAMED_PIPE,
    2047,
    METHOD_NEITHER,
    FILE_READ_DATA | FILE_WRITE_DATA,
);
pub const FSTL_PIPE_INTERNAL_READ_OVFLOW: u32 = CTL_CODE(
    FILE_DEVICE_NAMED_PIPE,
    2048,
    METHOD_BUFFERED,
    FILE_READ_DATA,
);
pub const FILE_PIPE_READ_DATA: u32 = 0x00000000;
pub const FILE_PIPE_WRITE_SPACE: u32 = 0x00000001;
STRUCT! {struct FILE_PIPE_ASSIGN_EVENT_BUFFER {
    EventHandle: HANDLE,
    KeyValue: c_ulong,
}}
pub type PFILE_PIPE_ASSIGN_EVENT_BUFFER = *mut FILE_PIPE_ASSIGN_EVENT_BUFFER;
STRUCT! {struct FILE_PIPE_PEEK_BUFFER {
    NamedPipeState: c_ulong,
    ReadDataAvailable: c_ulong,
    NumberOfMessages: c_ulong,
    MessageLength: c_ulong,
    Data: [c_char; 1],
}}
pub type PFILE_PIPE_PEEK_BUFFER = *mut FILE_PIPE_PEEK_BUFFER;
STRUCT! {struct FILE_PIPE_EVENT_BUFFER {
    NamedPipeState: c_ulong,
    EntryType: c_ulong,
    ByteCount: c_ulong,
    KeyValue: c_ulong,
    NumberRequests: c_ulong,
}}
pub type PFILE_PIPE_EVENT_BUFFER = *mut FILE_PIPE_EVENT_BUFFER;
STRUCT! {struct FILE_PIPE_WAIT_FOR_BUFFER {
    Timeout: LARGE_INTEGER,
    NameLength: c_ulong,
    TimeoutSpecified: c_uchar,
    Name: [wchar_t; 1],
}}
pub type PFILE_PIPE_WAIT_FOR_BUFFER = *mut FILE_PIPE_WAIT_FOR_BUFFER;
STRUCT! {struct FILE_PIPE_CLIENT_PROCESS_BUFFER {
    ClientSession: *mut c_void,
    ClientProcess: *mut c_void,
}}
pub type PFILE_PIPE_CLIENT_PROCESS_BUFFER =
    *mut FILE_PIPE_CLIENT_PROCESS_BUFFER;
pub const FILE_PIPE_COMPUTER_NAME_LENGTH: usize = 15;
STRUCT! {struct FILE_PIPE_CLIENT_PROCESS_BUFFER_EX {
    ClientSession: *mut c_void,
    ClientProcess: *mut c_void,
    ClientComputerNameLength: c_ushort,
    ClientComputerBuffer: [wchar_t; FILE_PIPE_COMPUTER_NAME_LENGTH + 1],
}}
pub type PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX =
    *mut FILE_PIPE_CLIENT_PROCESS_BUFFER_EX;
pub const MAILSLOT_CLASS_FIRSTCLASS: u32 = 1;
pub const MAILSLOT_CLASS_SECONDCLASS: u32 = 2;
pub const FSCTL_MAILSLOT_PEEK: u32 =
    CTL_CODE(FILE_DEVICE_MAILSLOT, 0, METHOD_NEITHER, FILE_READ_DATA);
STRUCT! {struct FILE_MAILSLOT_PEEK_BUFFER {
    ReadDataAvailable: c_ulong,
    NumberOfMessages: c_ulong,
    MessageLength: c_ulong,
}}
pub type PFILE_MAILSLOT_PEEK_BUFFER = *mut FILE_MAILSLOT_PEEK_BUFFER;
